# Rust -- 所有权

`u32`这种类型是占用内存字节数固定的类型，而`String`这种类型，是占
用字节数不固定的（动态的）类型。一般来说，对于固定字节数的类型，会默认放
在栈上（栈帧中）；而不固定字节数的类型，会默认创建在堆上（成为堆上的一个
资源），然后在栈上用一个局部变量来指向它。对于字符串这种动态字节数的类型来说，在变量的再赋值
上，`Rust`除了拷贝字符串的引用外，还做了更多事情。

所有权是`Rust`最特有的特性，他让`Rust`无需`GC`就可以保证内存安全。

### 所有权
- `Rust`的核心特性就是所有权
- `Rust`采用了特殊的管理方式
    - 内存是通过一个所有权系统来管理的，其中包含一组编译器在编译时检查的规则
    - 当程序运行时，所有权特性不会减慢程序的运行速度 

### Stack & Heap

- `Rust`这样的系统级编程语言里，一个值是在堆上还是在栈上对语言的行为和你为什么要做某些决定是有更大的影响的

#### 存储数据
- Stack
    - 所有在`Stack`上的数据必须拥有已知的固定大小，`Stack`遵循先进后出的原则
    - 把值进行压栈操作不叫分配
    - 因为指针是已知固定大小，可以放在`Stack`上
    - 数据压栈比`heap`上分配快

- Heap
    - `Heap`内存组织性差一些，当把数据放入`heap`时，会请求一定数量的空间
    - 操作系统在`heap`里面找到一块足够大的空间，并标记为在用，并返回这个空间的地址，这个过程叫做分配

    

#### 所有权存在的原因
- 所有权解决的问题： 
    - 跟踪代码的哪些部分正在使用`heap`的哪些数据
    - 最小化`heap`上的重复数据量
    - 清理`heap`上未使用的数据以避免空间不足 


### 规则
所有权的基础是三条定义：

- `Rust`中，每一个值（资源）都有一个所有者；
- 任何一个时刻，一个值只有一个所有者；
- 当所有者所在作用域结束的时候，值会被释放掉

三个规则，涉及两个概念，`所有者`，`作用域`。
所谓所有者，在代码中，就表示为`变量`。

- 所有者会用变量名来表示。
- 变量的作用域，就是变量有效（`valid`）的那个区间。
     就是在一对花括号括起的里面部分中，从变量创建时开始，到花括号结束的地方


### RAII

堆内存资源随着关联的栈上局部变量一起被回收的内存管理特性，叫作`RAII`
（Resource Acquisition Is Initialization）。

### 移动还是复制

- 默认做复制操作的有：
    - 所有的整数类型，比如`u32`,
    - 布尔类型，`bool`
    - 浮点数类型：`f32`, `f64`
    - 字符类型 `char`
    - 由以上类型组成的元组类型 `Tuple`，如（`i32`, `i32`, `char`）

- 其它类型，默认都是做值的移动操作。


### 借用与引用
借用是站在资源拥有者角度来说的，引用是站在想借这个资源的变量角度来说的。

在`Rust`中，引用就在变量前用`“&”`符号来表示，比如`&x`。其实，引用也是一种值，并且是**固定长度的值**。既然是值，当然可以赋给另一个变量。既然是固定长度的值，那其实做的就是引用的复制操作。

### 不可变引用、可变引用

- 引用包含不可变引用和可变引用
- `&x` 对变量`x`的不可变引用
- `&mut x` 对变量`x`的可变引用

### 引用的作用域

引用的作用域是从**它定义到它最后一次使用时结束**！如果它定义了，但并没有被使用，那它的作用域就只有它定义的那一行，即，出生即死亡。

同时，**还存在一条规则**：一个资源的可变引用与不可变引用的作用域**不能交叠**（overlap）！也可以说不能同时存在

### 关于引用（借用）的规则

- 引用（不可变引用和可变引用都是）变量的作用域不会长于所有权变量的作用域。肯定的，不然就会出现悬锤引用了，这是典型的内存安全问题。`Rust`中的引用必定是有效的；
- 一个资源的可变引用与不可变引用的作用域不能交叠（overlap），也可以说不能同时存在；
- 某个时刻对某个资源只能存在一个可变引用，不能有超过一个可变引用同时存在；
- 一个资源的不可变引用，可以同时存在多个；

以上规则的示例：

```
//本代码不可被编译，因为存在对一个资源的多个引用
fn main() {
    let mut a = 10u32;
    let b = &mut a;
    *b = 20;
    let d = &mut a;
    println!("{b}");
}

//本代码不可编译，因为可变与不可变overlap了
fn main() {
    let mut a = 10u32;
    let c = &a; // 这句位置放在了这里
    let b = &mut a;
    *b = 20;
    println!("{c}");
}

//不可编译，因为1.超出引用作用域，2.overlap
fn main() {
    let mut a = 10u32;
    let b = &mut a;
    *b = 20;
    let c = &a;
    println!("{b}");
}
```

### 可变引用的排它性

- 不可变引用可以被复制
- 可变引用不能被复制，只能被move

示例：

```
//不可编译，因为引用排他性
fn main() {
    let mut a = 10u32;
    let r1 = &mut a;
    let r2 = r1;
    println!("{r1}")
}

//可编译
fn main() {
    let mut a = 10u32;
    let r1 = &mut a;
    let r2 = r1;
    println!("{r2}")
}
```
**注意**：不要想着既然r2是从r1处借来的，那么等`r2`使用完再管`r2`借回来，一旦你将可变引用 `r1` 转移给了 `r2`，`r1` 就不再有效，不能通过 `r2` 将引用“借回”给 `r1`。也就是说，Rust 中不存在将引用从一个借用再“借回”的机制。想借，从原处借，即过重新借用`a`来获得新的引用

### 用&和&mut来改进函数的定义

函数的形参接受实参的过程，就是变量绑定值的过程，跟前面那些普通的变量绑定是一个道理。不过函数的参数是这个新函数的局部变量。
从代码可以看到，Rust的代码非常清晰。如果一个函数参数接受的是可变引用，或所有权参数，那么它里面的逻辑一般都会对引用的资源进行修改。如果一个函数参数只接受不可变引用，那么它里面的逻辑，就一定不会修改被引用的资源。


示例如下：

```
fn foo(s : String) {
    println!("{s}");
}

fn foo1(s : String) -> String{
   println!("{:?}",s);
   s
}

fn foo2(s : &String) {
    println!("{:?}",s);
}

fn foo3(s : &mut String) {
    s.push_str("You are batman");
}

fn main() {
    let s1 = String::from("i am sb");
    //foo(s1); 会报错  需要foo(s1.clone());
    
    // let s2 = foo1(s1);
    // println!("{:?}",s2); //不会报错 但是不能和下面的共存
    
    //foo2(&s1);
    //println!("{}",s1);
    
    foo3(&mut s1);
    println!("{}",s1);
}   
```


### 补充资料
- rust 教材：[https://github.com/sunface/rust-course](https://github.com/sunface/rust-course)
- rust官网资料：[https://www.rust-lang.org/zh-CN/learn](https://www.rust-lang.org/zh-CN/learn)
- rust学习资料整理，欢迎star：[https://github.com/sjinzh/awesome-rust-list#learning-resources](https://github.com/sjinzh/awesome-rust-list#learning-resources)
- 今年临时资料 [https://zhuanlan.zhihu.com/p/458838545?utm_id=0](https://zhuanlan.zhihu.com/p/458838545?utm_id=0)

