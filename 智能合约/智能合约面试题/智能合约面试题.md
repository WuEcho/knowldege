## 智能合约面试题

1. **私有、内部、公共和外部函数的区别**：
   - **私有函数**：只能在同一合约中调用，无法从继承的合约或外部调用。
   - **内部函数**：可以在同一合约或继承的合约中调用，外部无法访问。
   - **公共函数**：可以从内部和外部调用，是默认的函数可见性修饰符。
   - **外部函数**：只能从外部调用，不能从合约内部调用，除非使用 `this.` 来调用。

2. **智能合约大小的限制**：
   智能合约的大小限制在 24KB 左右。以太坊 EVM 对合约的字节码大小设置了 24KB 的限制，超过此限制将无法部署。

3. **CREATE 和 CREATE2 的区别**：
   - **CREATE**：使用随机生成的地址来部署合约，地址依赖于发起交易的地址和 nonce。
   - **CREATE2**：允许指定合约地址，地址基于创建者的地址、盐和字节码哈希。这使得 CREATE2 更适合预测合约地址的场景。

4. **Solidity 0.8.0 版本对算术运算的重大变化**：
   在 Solidity 0.8.0 中，默认开启了算术运算的溢出和下溢检查。任何导致溢出或下溢的操作会自动抛出错误，不再默默忽略或绕过。

5. **代理合约需要的特殊 CALL**：
   代理合约通常使用 `delegatecall` 来调用目标合约的函数。`delegatecall` 允许在代理合约的上下文中执行目标合约的代码，而不改变存储。

6. **EIP-1559 之前如何计算以太坊交易的美元成本**：
   计算交易成本时，使用 `gasPrice * gasUsed` 公式得到交易的 gas 成本，然后乘以当前 ETH 的价格来计算美元成本。

7. **在区块链上创建随机数的挑战**：
   区块链是一个确定性系统，因此创建真正的随机数很困难。常见挑战包括防止矿工操纵区块头信息（如 `blockhash`）来预测和控制随机数的结果。

8. **荷兰式拍卖和英式拍卖之间的区别**：
   - **荷兰式拍卖**：价格从高开始逐渐降低，直到有人接受当前价格。
   - **英式拍卖**：参与者以递增方式出价，直到没有更高的出价者为止。

9. **ERC20 中的 transfer 和 transferFrom 之间的区别**：
   - **transfer**：直接从调用者账户向接收者账户转账。
   - **transferFrom**：允许第三方（通常是已授权的账户）从某个账户中转账。

10. **地址 allowlist 使用映射或数组的优劣**：
    使用映射效率更高，因为可以 O(1) 检查地址是否存在，而数组的查找需要 O(n)。映射还可以更灵活地控制添加和删除地址。

11. **为什么不应该使用 tx.origin 进行身份验证**：
    `tx.origin` 可能导致安全风险，因为它返回的是原始调用者的地址，在代理或其他合约调用的场景下容易受到重入攻击或恶意合约操纵。应该使用 `msg.sender` 进行身份验证。

12. **以太坊主要使用的哈希函数**：
    以太坊主要使用 `keccak256` 哈希函数，它基于 SHA-3 算法。

13. **1 Ether 相当于多少个 gwei**：
    1 Ether = 1,000,000,000 gwei（10^9 gwei）。

14. **1 Ether 相当于多少个 wei**：
    1 Ether = 1,000,000,000,000,000,000 wei（10^18 wei）。

15. **assert 和 require 之间的区别**：
    - **assert**：用于不可恢复的内部错误或不变量检查，失败时会消耗所有剩余的 gas。
    - **require**：用于输入验证或条件检查，失败时仅返回剩余 gas，抛出异常并返回错误消息。

16. **什么是闪电贷**：
    闪电贷允许用户在一次交易中借入资金，并在同一交易中归还，如果未归还，整个交易将回滚。闪电贷通常用于套利、再融资等。

17. **什么是检查效果（check-effects）模式**：
    这是一个安全设计模式，要求在修改状态变量之前检查条件和执行外部调用，以防止重入攻击。

18. **运行独立验证节点所需的最小以太数量**：
    运行以太坊 2.0 验证节点需要至少 32 ETH。

19. **fallback 和 receive 之间的区别**：
    - **receive**：当合约接收到 ETH 且没有指定数据时调用。
    - **fallback**：当合约接收到数据或没有匹配函数时调用，且可以用于无 `receive` 函数的 ETH 接收。

20. **什么是重入攻击**：
    重入攻击是指在执行函数期间外部合约又回调到原始函数，导致逻辑反复执行。


21. **上海升级后，每个区块的 gas 限制是多少？**  
   上海升级后，每个区块的 gas 限制维持在 30,000,000 gas。该值可以通过链上治理进行调整。

22. **什么阻止无限循环永远运行？**  
   以太坊中的每个操作都有一定的 gas 成本，合约在 gas 耗尽时会停止执行。如果合约进入无限循环并消耗完所有分配的 gas，EVM 将终止该合约执行并回滚状态更改。

23. **tx.origin 和 msg.sender 之间有什么区别？**  
   - **tx.origin**：指最初发起交易的外部账户地址，不会在内部调用中变化。
   - **msg.sender**：是当前调用的直接发起者，可能是外部账户或合约。`msg.sender` 在每次调用时会根据调用的上下文进行更新，通常用于身份验证。

24. **如何向没有 payable 函数、receive 或 fallback 的合约发送以太？**  
   不能直接向没有 `payable` 函数、`receive` 函数或 `fallback` 函数的合约发送 ETH。如果尝试这样做，交易会失败并回滚。

25. **view 和 pure 之间有什么区别？**  
   - **view**：函数可以读取区块链上的状态，但不能修改状态。
   - **pure**：函数既不能读取区块链上的状态，也不能修改状态。它只能使用传递的参数进行计算。

26. **ERC721 中的 transferFrom 和 safeTransferFrom 之间有什么区别？**  
   - **transferFrom**：不执行接收合约的检查，因此可能会导致代币转移到不兼容的地址。
   - **safeTransferFrom**：在转移代币前会检查接收地址是否实现了 `onERC721Received` 接口，确保代币不会被锁定在无法处理它们的合约中。

27. **如何将 ERC1155 代币转换为非同质化代币？**  
   ERC1155 是多代币标准，支持同质化和非同质化代币。要使某种 ERC1155 代币表现为非同质化代币，可以给该代币分配一个唯一的 `id`，并确保每个 `id` 对应的代币总供应量为 1。

28. **访问控制是什么，为什么重要？**  
   访问控制用于限制哪些用户或合约可以调用某些功能。它在安全性方面至关重要，因为它可以防止未经授权的用户访问关键功能或资源，保护智能合约免受恶意攻击或意外操作。

29. **修饰符（modifier）的作用是什么？**  
   修饰符用于修改函数的行为。它们可以在函数执行前或后执行特定的代码，通常用于条件检查（如访问控制）或逻辑复用，以确保合约的状态符合预期。

30. **uint256 可以存储的最大值是多少？**  
    `uint256` 可以存储的最大值为 `2^256 - 1`，即：
    ```text
    115,792,089,237,316,195,423,570,985,008,687,907,853,269,984,665,640,564,039,457,584,007,913,129,639,935
    ```

31. **什么是浮动利率和固定利率？**  
    - **浮动利率**：利率随市场条件波动，可能随时间上下调整。
    - **固定利率**：利率在整个贷款或投资期间保持不变，不受市场变化影响。


## 中级

### **Transfer 和 Send 之间有什么区别？为什么不应该使用它们？**
- **`transfer` 和 `send`** 都用于发送以太币：
  - **`transfer`** 会在交易失败时自动回滚，并消耗 2300 gas。
  - **`send`** 返回布尔值，表示交易是否成功，失败时不会自动回滚，需要手动处理错误。
- 不建议使用它们是因为这两个函数的 gas 限制（2300 gas）在复杂的接收方合约中可能不足，导致交易失败。使用 `call` 是更灵活的选择。

### **如何在 Solidity 中编写高效的 gas 循环？**
1. **最小化循环内的操作**：避免循环中调用复杂的函数或修改存储。
2. **尽量使用 `memory` 而不是 `storage`**：存储访问比内存访问昂贵。
3. **限制循环的次数**：尝试将循环的上限设为固定值，避免无限循环。

### **代理合约中的存储冲突是什么？**
代理合约使用 `delegatecall` 调用实现合约，`delegatecall` 在调用过程中使用代理合约的存储。存储冲突指的是实现合约和代理合约在相同的存储槽中使用数据，导致意外行为。要避免冲突，代理和实现合约应该有明确的存储布局。

### **ABI.encode 和 ABI.encodePacked 之间有什么区别？**
- **`ABI.encode`** 会对数据进行标准的 ABI 编码，适合复杂的输入和固定大小的数据。
- **`ABI.encodePacked`** 会对数据进行紧凑编码，适用于较小的输入和固定大小的数据，但不同类型的数据紧凑编码可能导致哈希碰撞，带来安全漏洞。

### **uint8、uint32、uint64、uint128、uint256 都是有效的 uint 大小。还有其他的吗？**
是的，Solidity 还支持其他的 `uint` 大小，如 `uint16`、`uint24`、`uint40` 等，范围为 `uint8` 到 `uint256`，并且步长为 8 位。

### **在权益证明之前后，block.timestamp 发生了什么变化？**
- **PoW（权益工作证明）**中，矿工控制 block.timestamp，但有一定的限制。
- **PoS（权益证明）**中，block.timestamp 由验证者确定，但受到更多的共识协议约束，因此更加准确且不容易被操控。


### 乘以和除以二的倍数的 gas 高效替代方法是什么？

在 Solidity 中，乘以或除以 2 的倍数可以用位运算符来实现，这是一种相对于标准乘法和除法更高效的方法。

具体来说，使用左移（<<）运算符来实现乘法，使用右移（>>）运算符来实现除法。

位运算比标准的算术运算更快，在 EVM 中，位运算的 Gas 成本通常低于乘法和除法运算。

### **什么是抢跑（frontrunning）？**
抢跑是指恶意用户通过观察未完成的交易（如在 mempool 中）并在它之前插入自己的交易，从而获得经济利益的一种攻击手段。

### **什么是提交-揭示方案，何时使用它？**
提交-揭示方案是一种用于确保公平性的机制，常用于投票或竞拍。参与者首先提交隐藏的承诺（例如哈希值），然后在揭示阶段公开承诺的真实值，防止其他参与者在揭示之前获取信息并做出有利的调整。

### **在什么情况下，abi.encodePacked 可能会产生漏洞？**
当使用 `abi.encodePacked` 编码动态类型时（如字符串或字节数组），可能会导致哈希碰撞。例如，`abi.encodePacked("abc", "def")` 和 `abi.encodePacked("ab", "cdef")` 可能产生相同的哈希值，导致安全问题。

### **以太坊如何确定 EIP-1559 中的 BASEFEE？**
`BASEFEE` 根据区块中 gas 的使用情况自动调整：
- 当区块的 gas 使用量高于目标 gas 限制时，`BASEFEE` 增加。
- 当 gas 使用量低于目标时，`BASEFEE` 减少。

### 请简单介绍一下eip1559
2021年8月作为“伦敦升级”的核心内容被部署到以太坊主网。它彻底改变了以太坊的交易费用机制，旨在解决原有Gas费模型（第一价格拍卖）的低效问题,并为ETH引入通缩机制。

1. ​基础费用（Base Fee）​
    - ​动态调整：每个区块的基础费用由协议自动计算，根据前一区块的拥堵程度动态调整。如果区块利用率超过50%（即Gas使用量超过区块目标容量），基础费用会上涨；反之则下降。
    - 全网统一：所有用户在同一区块中的交易支付相同的基础费用，无需猜测合理价格。

    - 销毁机制：基础费用会被永久销毁（Burn），而非支付给矿工，这减少了ETH的流通量，增加了其稀缺性。

2. ​优先费（Priority Fee，小费）​
    - 激励矿工：用户可额外支付一笔“小费”给矿工，以激励他们优先打包自己的交易。这在网络拥堵时尤为重要。
    - 自主设置：小费由用户自行决定，类似于传统竞价机制，但金额通常远低于原有的Gas费。

3. ​区块Gas上限调整
区块的Gas上限从固定值（例如1500万Gas）变为弹性范围（例如目标1500万，上限3000万），允许区块在极端拥堵时短暂扩容，缓解交易积压。

（1）​**chainId**

​含义：标识以太坊网络的链ID（如主网为 1），防止交易在不同链之间被重放。
​位置：显式包含在交易数据中（此前通过签名隐含）。
​
（2）​**maxPriorityFeePerGas（优先级费用）​**

​含义：用户愿意支付给矿工的小费​（单位：Gwei/Gas），用于激励矿工优先打包交易。
​示例：若设为 2 Gwei，则矿工每单位 Gas 至少获得 2 Gwei。

（3）​**maxFeePerGas（最大总费用）​**

​含义：用户愿意支付的单 Gas 最高总费用​（单位：Gwei/Gas），包含 baseFee（基础费用）和 priorityFee（小费）。实际支付的费用为：
​**实际费用 = min(maxFeePerGas, baseFee + priorityFee)**
​作用：当网络拥堵时，防止用户因 baseFee 上涨而支付过高费用。
​
（4）​**gasLimit**

​含义：用户预估的Gas 用量上限，防止因合约执行异常（如死循环）耗尽 Gas。即使实际 Gas 使用未达此值，未用完的部分也会退还。

### **冷读（cold read）和热读（warm read）之间有什么区别？**
- **冷读（cold read）**：是指第一次读取存储或账户时，它的 gas 成本较高。
- **热读（warm read）**：是指在同一交易中，已经访问过的存储或账户再次读取时，gas 成本较低。

### **AMM 如何定价资产？**
自动做市商（AMM）通过公式（如恒定乘积公式 `x * y = k`）来定价资产。交易会根据当前的流动性池比例自动调整价格。

### **代理中的函数选择器冲突是什么，它是如何发生的？**
函数选择器是函数签名的哈希的前四个字节。在 EVM 中，当一个函数被调用时，它是通过这个函数选择器来识别要执行的具体函数的。

在代理模式中，一个代理合约会将所有调用转发给另一个合约（实现合约）。如果代理合约和实现合约中存在具有相同函数选择器的函数，就会发生冲突，导致代理合约无法正确地将调用转发到预期的函数。

为了避免函数选择器冲突，开发者需要确保在代理合约和其实现合约中不会有具有相同选择器的不同函数。这通常意味着需要仔细地设计合约的接口，并在添加新方法时考虑潜在的冲突

### **payable 函数对 gas 的影响是什么？**
`payable` 函数允许合约接收 ETH。在某些情况下，执行 `payable` 函数时，转账 ETH 的 gas 成本会增加，因为涉及到资金的处理。

### **什么是签名重放攻击？**
签名重放攻击是指攻击者使用已经签名的交易来多次执行相同的操作。通常通过在签名数据中加入 nonce 或链 ID 来防止该攻击。

### **什么是 gas griefing？**
Gas Griefing 指攻击者提交恶意交易、部署特殊合约，或利用合约逻辑缺陷，在不直接盗取资金的前提下：
- 使关键合约操作失败（如 transfer, callback, external call）
- 强迫其他用户承担异常 gas 成本
- 阻止 DAO 投票/清算/自动化执行等功能
- 消耗 keeper / relayer / bot 的资源，制造 DoS

防御方案：
1.使用 try/catch 捕获外部调用失败
2.限定 gas 提供量（使用 .call{gas: N}）
3.外部合约交互尽可能设为 可选 / 不可阻断
4.审查合约执行路径中的 gas 上限



### **如何设计一个石头-剪刀-布的智能合约游戏，使玩家无法作弊？**
可以使用提交-揭示机制设计石头-剪刀-布游戏。在提交阶段，玩家提交哈希化的选择和随机数。在揭示阶段，玩家公布选择和随机数以证明提交的选择，从而防止提前泄露。

### **自由内存指针是什么，它存储在哪里？**
自由内存指针是指当前可以安全使用的内存地址。它存储在内存位置 0x40，并指向可以被写入数据的下一块空闲内存。

| 地址范围  | 用途                                    |
|-----------|-----------------------------------------|
| 0x00–0x1F | scratch space(EVM 内存中预留的一小段区域，用于临时存放数据，尤其是在执行某些计算（如哈希、ABI 编码等）过程中临时拼接或传递参数) |
| 0x20–0x3F | 自由内存指针值存储槽（FMP 位置           |
| 0x40      | 自由内存指针位置（即 mload(0x40) = 0x80） |
| 0x60–0x7F | 临时预留空间                            |
| 0x80–...  | 实际可用的自由 memory 开始地址          |


### **接口中有效的函数修饰符有哪些？**
接口中的函数声明不能使用自定义修饰符（如 onlyOwner
可以使用的：
可见性：必须为 external（接口函数默认 external）。
状态可变性：如 view、pure、payable。


### **函数参数中的 memory 和 calldata 有什么区别？**
- **`memory`**：表示临时存储的数据，可以修改。
- **`calldata`**：表示不可修改的外部输入数据，通常用于函数参数中。

### **描述三种存储 gas 成本类型。**
1. **存储写入成本**：将数据写入到链上的存储槽 20,000 gas。
2. **存储重写成本**：将数据重新写入已经使用的存储槽 5000gas。
3. **存储删除成本**：移除存储中的数据，并获得部分 gas 退款，先花费5000，返回15000。

### **为什么可升级合约不应该使用构造函数？**
在可升级合约中，使用构造函数的逻辑只在合约首次部署时运行，但实现合约可能会被多次代理到不同的合约实例。因此，应使用初始化函数（如 `initialize`）而非构造函数。

### **UUPS 和 Transparent Upgradeable Proxy 模式之间有什么区别？**
- **UUPS（可升级代理）**依赖实现合约中的升级函数来管理升级。
- **透明代理模式** 将升级逻辑放在代理合约中，并限制只有特定的管理员可以调用升级函数。

### **如果合约通过 delegatecall 调用一个空地址或之前已自毁的实现，会发生什么？如果是常规调用而不是 delegatecall 呢？**
- **delegatecall** 调用空地址或自毁的合约会失败并回滚交易。
- **常规调用** 会失败并回滚交易或触发异常，但具体行为取决于合约的具体实现。

### **ERC777 代币存在什么危险？**
ERC777 的重新入侵（reentrancy）问题尤为突出，特别是在处理多步交易时。如果不小心，攻击者可以在一次交易未完成时调用回调函数，从而干扰交易流程。

### **根据 Solidity 风格指南，函数应该如何排序？**
按照 Solidity 风格指南，函数应该按照如下顺序排序：
1. 构造函数
2. `receive` 和 `fallback`
3. 外部函数
4. 公共函数
5. 内部函数
6. 私有函数

## 略难

### **定点算术如何表示数字？**
定点算术使用固定的小数位来表示数字。例如，`UFixed256x18` 表示一个定点数，其中 256 位用于整数部分，18 位用于小数部分。数字 `1.23` 在定点算术中可以表示为 `1230000000000000000`，将实际值乘以 10^18 进行存储。

### **什么是 ERC20 授权抢跑攻击？**
授权抢跑攻击是一种攻击手段，攻击者利用用户通过 `approve` 函数授权的时间差，在授权生效之前或之后通过 `transferFrom` 提取资金。要防止此类攻击，可以使用 `permit` 和 `safeApprove` 函数。

### **什么操作码可以实现 `address(this).balance`？**
操作码 `BALANCE` 可以获取指定地址的余额。`address(this).balance` 会使用 `BALANCE` 操作码来检索当前合约的余额。

### **一个 Solidity 事件可以有多少个参数？**
Solidity 事件最多可以有 17 个参数，其中最多 3 个可以被标记为 `indexed`。

### **什么是匿名 Solidity 事件？**
匿名事件（anonymous event）是在定义事件时使用 `anonymous` 关键字的事件。这些事件不会自动在日志中记录其名称，因此更难通过其名称进行搜索。

### **在什么情况下，函数可以接收映射作为参数？**
在 Solidity 中，函数不能接收映射作为参数。映射是非序列化的，无法直接传递给函数。

### **ERC4626 中的通胀攻击是什么？**
ERC4626 是一个代币化金库的标准。在通胀攻击中，恶意用户通过操纵代币的供应（如无限铸造）来稀释其他用户的份额，从而获取不正当的收益。防止这种攻击需要在代币供应和赎回逻辑中进行严格的检查和限制。1.限制新代币的铸造上限 2.实施逐步铸造机制 3.通胀抵消机制 

### **一个 Solidity 函数可以有多少个参数？**
Solidity 函数的参数数量理论上没有明确的限制，但受限于 EVM 的调用栈和函数的整体 gas 消耗。通常建议保持参数数量在合理范围内以避免复杂性。

### **`uint64[] x = [1,2,3,4,5]` 使用了多少个存储槽？与内存有何不同？**
`uint64[] x = [1,2,3,4,5]` 在存储中使用 2 个槽：
1. 第一个槽存储数组的长度（5）。
2. 第二个槽及其后的连续槽存储数组的实际数据。
在内存中，数组数据连续存储在一个区域，没有槽的概念。

### **上海升级之前，在什么情况下，`returndatasize()` 比 `push zero` 更有效？**
在特定情况下（例如在低 gas 环境下），`returndatasize()` 可能比 `push zero` 更有效，尤其是在需要经常检查返回数据大小时。由于 `returndatasize` 是一个简单的操作，它的 gas 消耗可能比 `push zero` 更低。

### **为什么编译器会在 Solidity 合约中插入 `INVALID` 操作码？**
编译器在生成的字节码中插入 `INVALID` 操作码（如 `0xfe`），作为意外代码路径的终止标志。遇到 `INVALID` 操作码时，EVM 会触发回滚。这可以防止合约在未知状态下继续运行。

### **自定义错误和带错误字符串的 `require` 在 EVM 层面编码有什么区别？**
自定义错误在 EVM 层面编码时更节省 gas，因为它们只存储错误标识符和参数，而不是完整的字符串。带错误字符串的 `require` 则存储整个字符串，这会占用更多的存储和 gas。

### **Compound DeFi 公式中的 `kink` 参数是什么？**
`kink` 是一个关键参数，定义了 Compound 中利率模型的拐点。在 `kink` 之前，利率按较慢的速度上升；超过 `kink` 后，利率上升速度会加快。这用于控制利用率和激励借贷行为。

### **函数名称如何影响 gas 成本，如果有的话？**
函数名称本身不会直接影响 gas 成本，但函数名称越长，合约的字节码越大，部署合约的成本就会增加。不过，调用函数时使用函数选择器，而选择器的长度固定，因此函数名长度不影响调用时的 gas 成本。

### **`ecrecover` 存在什么常见漏洞？**
`ecrecover` 可能返回地址 `0x0`，这是无效的，但在合约逻辑中可能会被误认为是有效地址，从而导致安全漏洞。开发者应当检查 `ecrecover` 的返回值是否为 `0x0`，并进行适当处理。

### **乐观 Rollup 和 zk-rollup 之间有什么区别？**
- **乐观 Rollup** 假定提交的交易是有效的，并在之后通过挑战机制验证其有效性。如果有人质疑交易的有效性，则需要提交证明。
- **zk-rollup** 使用零知识证明来验证交易的有效性，所有交易在提交时就已经过验证，因此不需要挑战机制。

### **EIP1967 如何选择存储槽，有多少个存储槽，它们代表什么？**
EIP1967 为代理合约的存储槽定义了固定的偏移量：

| 用途         | 说明                   | 存储槽计算                                                      |
|--------------|------------------------|-----------------------------------------------------------------|
| 实现合约地址 | implementation address | bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1) |
| 管理员地址   | admin address          | bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1)          |
| Beacon 地址  | 用于 Beacon Proxy      | bytes32(uint256(keccak256("eip1967.proxy.beacon")) - 1)         |

- `0x360894A13BA1A3210667C828492DB98DCA3E2076CC3735A920A3CA505D382BBC` 用于存储实现合约地址。
- `0xA3F0AD74E542BCA3ACD23BCF07F01300234ABDF5CFFD4B02D726CC8D37D02A2D` 用于存储管理者地址。

### **1 个 Szabo 价值多少？**
1 个 Szabo 等于 `10^12` wei，或 `0.000001` ETH。

### **delegatecall 除了在代理中使用之外还可以用于什么？**
`delegatecall` 还可以用于：
- **代码复用**：不同的合约可以通过 `delegatecall` 调用共享逻辑合约的代码。
- **状态共享**：多个合约可以通过 `delegatecall` 共享一个状态存储，从而实现复杂的合约架构。

### **在什么情况下，一个在以太坊上运行的智能合约在 Polygon 或 Optimism 上无法运行？（假设没有依赖于外部合约）**
- **gas 限制不同**：在 L2 上，某些操作的 gas 成本可能不同。
- **预言机的返回值**：L2 网络上的预言机可能会返回与主网不同的数据。
- **跨链桥调用**：如果合约依赖于跨链桥的操作，可能会因 L2 上不同的桥实现而出问题。

### **智能合约如何在不更改地址的情况下改变其字节码？**
智能合约可以通过代理合约（使用 `delegatecall`）或升级合约来改变其行为，而不改变合约地址。这通常通过像 EIP1967 或 UUPS 这样的代理模式实现。

### **在循环中将 `msg.value` 放入有什么危险？**
在循环中多次处理 `msg.value` 可能导致不准确的金额计算，或在恶意输入的情况下，导致多次意外的支付或退款。因此，应小心使用 `msg.value` 并在循环外部进行适当的分配。

### **描述一个函数 `calldata`，该函数接受一个动态长度的 `uint128` 数组作为参数，当传递 `[uint128(1),2,3,4]` 作为参数时会发生什么？**
```solidity
function example(uint128[] calldata _array) external {
    // 函数体
}
```
当传递 `[1,2,3,4]` 作为参数时，`calldata` 会按照数组的 ABI 编码方式将数据编码，并传递给合约函数。数组长度和元素按顺序存储在 `calldata` 中。

### **为什么严格的不相等比较比 ≤ 或 ≥ 更节省 gas？额外的操作码是什么？**
严格的不相等比较（`!=` 和 `==`）比 `≤` 或 `≥` 更节省 gas，因为后者需要两个比较操作符（例如，`≥` 转化为 `>` 和 `=` 的组合），而前者仅需一次操作。

### **如果代理调用一个实现，并且在被调用的函数中实现自毁，会发生什么？**
实现合约的 `selfdestruct` 操作会销毁实现合约，但不会影响代理合约。代理合约仍然存在，但再也无法调用已被销毁的实现合约。

### **变量作用域和堆栈深度之间有什么关系？**
在 Solidity 中，函数的局部变量存储在堆栈中。变量越多，堆栈的深度就越大，超出 1024 层的堆栈深度会导致 `stack too deep` 错误。因此，函数中局部变量的数量直接影响堆栈深度。

### **访问列表交易是什么？**
访问列表交易（Access List Transaction）是 EIP-2930 提出的交易类型，允许用户在交易中指定其访问的存储地址，以减少交易的 gas 成本。

### **如何使用 `mload` 操作码终止执行？**
可以通过读取内存中的数据并根据条件决定是否执行后续代码，结合 `revert` 或 `invalid` 操作码终止合约的执行。

### **在代理的上下文中，什么是信标（beacon）？**
信标是升级模式的一种，其中代理合约通过信标合约来确定实现合约地址。信标管理实现合约的地址，代理合约通过查询信标获取最新的实现合约地址。

### **为什么在进行治理投票之前需要对余额进行快照？**
快照机制确保在治理投票中，用户的投票权基于某个时间点的持有余额，而不是基于投票发生时的余额。这样可以防止投票权被操纵，如在投票前短时间内集中购买代币。

### **如何执行一个不需要用户支付 gas 的交易？**
可以通过 Meta-Transaction 实现，用户将签名的交易数据发送给第三方（如 Relayer），由第三方代为支付 gas 并提交交易。

### **在 Solidity 中，不使用汇编，如何获取 `calldata` 的函数选择器？**
bytes4(msg.data[:4])

### **以太坊地址是如何派生的？**
以太坊地址是通过从 ECDSA 公钥的 Keccak-256 哈希值中取后 20 个字节生成的。

### **什么是元代理标准？**
元代理（Meta-proxy）标准允许通过代理的方式，自动将合约调用路由到正确的实现合约，而不需要用户知道合约的确切实现地址。元代理标准用于管理多个合约的升级和版本控制。

### **如果 `try catch` 调用一个不会回滚的合约，但在 `try` 块内发生回滚，会发生什么？**
即使被调用的合约不会回滚，如果 `try` 块中的其他逻辑触发回滚，`catch` 块仍会捕获该回滚并执行错误处理逻辑。

### **如果用户调用代理并使代理进行 `delegatecall` 到 A，A 从其角度来看，`msg.sender` 是谁？从 B 的角度来看，`msg.sender` 是谁？从代理的角度来看，`msg.sender` 是谁？**
- 对于 A 来说，`msg.sender` 是调用代理的用户。
- 对于 B 来说，`msg.sender` 仍然是调用代理的用户。
- 对于代理来说，`msg.sender` 是实际发起调用的用户。

### **为什么大量合约字节码以 `6080604052` 开头？这个字节码序列是做什么的？**
字节码序列 6080604052 对应的 EVM Opcodes: PUSH1 0x80 PUSH1 0x40 MSTORE。
这段代码表示，向堆栈推入 0x40 和 0x80，然后执行 MSTORE 操作，它的两个操作数分别为 0x40 和 0x80。

整段代码等同于 MSTORE(0x40, 0x80)，也就是向内存中地址 0x40 处存储数据 0x80。

Solidity 内存空间预留了4 个 32 字节的插槽 slot，分别是：

0x00 起始的 64 字节: 哈希方法的暂存空间；

0x40 起始的 32 字节: 当前已分配内存大小，也称为空闲内存指针；

0x60 起始的 32 字节: 零槽，用作动态内存数组的初始值。

所以，MSTORE(0x40, 0x80)，用来设置空闲指针位

### **Uniswap V3 如何确定流动性区间的边界？**
Uniswap V3 使用刻度（tick）来表示价格区间，流动性提供者可以在特定的刻度范围内提供流动性，这样可以集中流动性到特定价格范围内。

### **什么是无风险利率？**
无风险利率是指在理论上没有违约风险的借款利率，通常基于政府债券或类似的无风险投资工具计算。

### **当一个合约通过 `call`、`delegatecall` 或 `staticcall` 调用另一个合约时，它们之间如何传递信息？**
通过这些调用方式，信息（如 `calldata` 和 `msg.sender`）在合约之间传递。`call` 和 `staticcall` 使用调用者的上下文传递数据，而 `delegatecall` 使用被调用者的上下文传递数据。

### **内存中的 `bytes` 和 `bytes1[]` 之间有什么区别？**
`bytes` 是动态大小的字节数组，在内存中是一个连续的字节块。`bytes1[]` 是定长字节数组的数组，每个元素是 `bytes1`，它们在内存中不一定是连续的。

这些问题涵盖了智能合约和 Solidity 编程中更深入的细节。

## 高难度

### **以太坊预编译合约的地址是什么？**
以太坊预编译合约的地址是从 `0x0000000000000000000000000000000000000000` 开始的地址段。常见的预编译合约包括：
- `0x0000000000000000000000000000000000000001`：`ecrecover`
- `0x0000000000000000000000000000000000000002`：`sha256`
- `0x0000000000000000000000000000000000000003`：`ripemd160`
- `0x0000000000000000000000000000000000000004`：`identity` (执行 `input` 数据不变的操作)

### **当函数数量超过 4 个时，Solidity 如何管理函数选择器？**
Solidity 使用函数选择器来标识函数，函数选择器是函数签名（前 4 个字节的 Keccak-256 哈希值）的前 4 个字节。函数选择器是用来在调用合约时找到正确的函数。函数选择器的管理并不直接受函数数量影响，但当函数数量超过 4 个时，函数选择器用于确定具体调用的函数。

### **如果对一个合约进行委托调用，而该合约又对另一个合约进行委托调用，那么在代理合约、第一个合约和第二个合约中，`msg.sender` 是谁？**
- 在代理合约中，`msg.sender` 是最初调用代理合约的地址。
- 在第一个合约中（被代理合约委托调用），`msg.sender` 仍然是最初调用代理合约的地址。
- 在第二个合约中（被第一个合约委托调用），`msg.sender` 仍然是最初调用代理合约的地址。

### **如果有的话，ABI 编码在 calldata 和 memory 之间有何不同？**
在 Solidity 中，ABI 编码是一种用于序列化和反序列化函数参数和返回值的标准格式。在函数调用时，函数参数被编码为 ABI 编码格式，并存储在 calldata 中。在函数内部，可以使用 msg.data 访问 calldata 中的数据。
ABI 编码在 `calldata` 和 `memory` 中的不同主要体现在存储方式和操作成本上：
- **`calldata`** 是不可变的，用于传递给合约的外部调用数据。它是只读的，费用较低，但在操作时不可以修改。
- **`memory`** 是可读写的，用于在合约内部存储和操作数据。操作内存数据可能会有更高的 gas 成本，但提供了更大的灵活性。

### **uint64 和 uint256 在 calldata 中的 ABI 编码有何不同？**
当使用 uint64 时，编码器会将其填充到 32 字节，以与 EVM 的字长对齐。
当使用 uint256 时，编码器不需要额外的填充，因为它的字长与 EVM 的字长完全相同。

### **什么是只读重入？**
只读重入（Read-Only Reentrancy）是指合约在执行只读操作时（例如调用 `view` 函数）发生的重入攻击。虽然只读操作不修改状态，但攻击者仍然可以利用这种重入来破坏逻辑或提取信息。
 Euler Finance采用read-only reentrancy guard

### **从不受信任的智能合约调用中读取（内存）字节数组的安全考虑是什么？**
读取不受信任的字节数组可能导致安全问题，如：
- **越界读写**：不受信任的字节数组可能包含恶意数据，导致越界访问。
- **数据污染**：不受信任的数据可能会污染内存，影响合约逻辑。

### **如果部署一个空的 Solidity 合约，在区块链上会有什么字节码，如果有的话？**
一个空的 Solidity 合约会部署一段包含初始化代码的字节码，但这段代码通常非常简单，可能包括基本的内存分配和存储初始化。

### **以太虚拟机如何定价内存使用？**
EVM 的内存定价是根据使用的字节数和操作复杂性来计算的。内存的分配和释放会产生 gas 费用，内存使用量直接影响 gas 成本。EIP1559之后，价格由以太坊网络动态决定。

### **智能合约的元数据部分存储了什么？**
智能合约的元数据部分通常包含编译器版本、源代码文件和其他调试信息，以帮助工具和开发者在分析合约时提供更丰富的上下文。

### **从 MEV 的角度来看，什么是叔块攻击？**
叔块攻击（Uncle Block Attack）是指攻击者通过创建并迅速传播“叔块”来影响交易顺序，从而从中获得矿工奖励或进行其他操控行为。

### **如何进行签名篡改攻击（malleability attack）？**
签名篡改攻击是指攻击者通过修改签名数据的某些部分（如 `v` 值），在不更改实际内容的情况下，使得交易变得无效或被重新使用。

### **在什么情况下，具有前导零的地址可以节省 gas，以及为什么？**
具有前导零的地址可以节省 gas，因为前导零在某些操作中可能被优化，减少了计算和存储的需求。具体节省量取决于合约的实现和操作。

### **`payable(msg.sender).call{value: value}("")` 和 `msg.sender.call{value: value}("")` 之间有什么区别？**
- `payable(msg.sender).call{value: value}("")` 显式地将 `msg.sender` 转换为 `payable` 地址，以便发送以太。
- `msg.sender.call{value: value}("")` 直接调用 `call`，但如果 `msg.sender` 不是 `payable` 地址，这种调用会失败。

### **一个字符串占用多少个存储槽？**
一个字符串的存储槽数目取决于字符串的长度。一般来说，每 32 字节的数据使用一个存储槽。字符串通常会占用多个存储槽，具体取决于它的长度和编码方式。

### **Solidity 编译器中的 `--via-ir` 功能是如何工作的？**
`--via-ir` 选项允许编译器通过中间表示（IR）生成字节码。此功能提供了一种更细粒度的优化和调试能力，有助于编译器优化和生成高效的字节码。

### **函数修饰符是从右到左调用还是从左到右调用，还是不确定的？**
函数修饰符（modifier）是按照从左到右的顺序依次调用的。修饰符的调用顺序是从最内层到最外层，这允许在函数执行之前和之后进行适当的设置和清理工作。

### **如果对一个合约进行委托调用，而执行了指令 `CODESIZE`，将返回哪个合约的大小？**
`CODESIZE` 操作码返回当前执行上下文的合约代码大小。在委托调用中，`CODESIZE` 返回的是被调用合约的代码大小。

### **为什么 ECDSA 对哈希而不是任意 bytes32 进行签名很重要？**
ECDSA 对哈希进行签名而不是任意 `bytes32` 是为了确保签名的安全性和效率。对数据进行哈希处理，可以将数据压缩成固定长度，并避免直接对大数据进行签名，提高了签名操作的安全性和性能。

### **描述符号操作测试（symbolic manipulation testing）是如何工作的。**
符号操作测试是一种测试技术，用于通过符号化输入数据来测试合约的行为。它允许对合约的不同执行路径进行分析，识别潜在的漏洞或错误，而无需实际执行所有可能的输入数据。

### **复制内存区域的最有效方式是什么？**
复制内存区域的最有效方式通常是使用 `memcpy` 函数或直接在汇编中使用 `mstore` 和 `mload` 操作码。这样可以高效地复制内存数据块。

### **如何在链上验证另一个智能合约是否触发了一个事件，而不使用预言机？**
可以通过监听和检查相关合约的事件日志来验证事件的触发。通过分析事件日志中的数据，可以确定事件是否发生，并提取相关信息。


```
pragma solidity ^0.8.0;

contract MyContract {
    event MyEvent(uint256 indexed id, string data);

    function myFunction(uint256 id, string memory data) public {
        emit MyEvent(id, data);
    }
}

```

验证事件合约

```
pragma solidity ^0.8.0;

contract MyVerifier {
    function verifyEvent(address contractAddress, uint256 id, string memory data) public view returns (bool) {
        MyContract myContract = MyContract(contractAddress);
        uint256 fromBlock = block.number - 100;
        uint256 toBlock = block.number;
        bytes32 eventHash = keccak256(abi.encodePacked("MyEvent(uint256,string)"));
        bool eventFound = false;
        for (uint256 i = fromBlock; i <= toBlock; i++) {
            bytes32[] memory topics = new bytes32;
            topics[0] = bytes32(eventHash);
            topics[1] = bytes32(id);
            bytes memory data = abi.encodePacked(contractAddress);
            uint256[] memory eventIds = myContract.getPastEvents("MyEvent", i, i, data, topics);
            if (eventIds.length > 0) {
                eventFound = true;
                break;
            }
        }
        return eventFound;
    }
}

```

在上面的代码中，MyVerifier 合约包含一个名为 verifyEvent 的函数，该函数用于验证另一个智能合约是否触发了 MyEvent 事件。该函数接受三个参数：contractAddress 是要验证的智能合约地址，id 是要验证的事件 id 参数，data 是要验证的事件 data 参数。该函数使用 getPastEvents 函数来检索事件日志，并检查是否存在与指定参数匹配的事件。


### **当调用 `selfdestruct` 时，以太何时转移？智能合约的字节码何时被擦除？**
调用 `selfdestruct` 时，以太会立即转移到指定的地址。、合约的存储和代码从状态中被移除，但是合约的地址仍然存在。合约的字节码不会被擦除，但是合约的地址不再被使用，因此合约的代码也不再被执行。

### 自由内存指针是什么？
自由内存指针是 Solidity 中的一个指针，它指向当前合约的内存空间中的下一个可用位置。在 Solidity 中，内存是一种临时存储空间，用于存储临时变量和函数参数。当您在 Solidity 中声明一个变量时，它将被分配到内存中，并且自由内存指针将被更新以指向下一个可用位置。在 Solidity 中，您可以使用 mload 和 mstore 操作码来读取和写入内存中的数据。自由内存指针是 Solidity 中的一个重要概念，因为它允许您在内存中动态分配空间，从而更有效地使用内存。

### **在什么条件下，Openzeppelin 的 Proxy.sol 会覆盖自由内存指针？为什么这样做是安全的？**
OpenZeppelin 的 `Proxy.sol` 可能会覆盖自由内存指针以确保代理合约的内部状态与实现合约一致。这种做法通过在升级时维护一致的内存布局来确保安全性，避免了状态不一致的问题。

### **为什么 Solidity 废弃了 "years" 关键字？**
Solidity 废弃了 "years" 关键字，可能是因为这种时间单位的处理不够精确或容易引发混淆。`years` 关键字可能被替换为更具体的时间单位，以提高时间计算的准确性和可靠性


### Solidity 编译器中的--via-ir 功能是如何工作的？

--via-ir 是 Solidity 编译器的一个选项，它可以启用基于中间代码（IR）的代码生成器。使用 IR 代码生成器，Solidity 可以生成 Yul 中间代码，然后再将其转换为 EVM 字节码。这种方法的优点是，它可以实现更强大的跨函数优化通道，同时也使代码生成更加透明和可审计。
您可以在命令行中使用 --via-ir 或在 standard-json 中使用 {"viaIR": true} 选项来启用基于 IR 的编码。在 Hardhat 中，可以在 hardhat.config.js 的 settings 字段下加入配置

```
solidity: {
  version: \"0.8.17\",
  settings: {
    \"viaIR\": true, //配置启用IR
    optimizer: {
      enabled: true,
      runs: 1000,
    },
  },
},

```

### verbatim 关键字的作用是什么，以及它可以在哪里使用？

智能合约中的 verbatim 关键字是 Solidity 语言的一部分。它的作用是将代码中的字符串字面量原样输出，而不进行转义或解析。这在编写智能合约时非常有用，因为它可以确保字符串的内容不会被意外地更改或破坏。例如，如果您需要在智能合约中编写一个包含 HTML 标记的字符串，那么使用 verbatim 关键字可以确保标记不会被解析或更改。verbatim 关键字可以在 Solidity 语言的任何地方使用，包括函数定义、变量声明和注释等。

### 在调用另一个智能合约时可以转发多少 gas？

在调用另一个智能合约时，可以转发的 gas 数量取决于您的智能合约的 gas 限制和 gas 价格。如果您的智能合约的 gas 限制为 1000000，gas 价格为 20 Gwei，那么您可以转发的 gas 数量为 1000000。

### signextend 操作码有什么用

用于将有符号整数的位数扩展到更高的位数。在 Solidity 中，有符号整数使用补码表示法，其中最高位表示符号位。当您使用 signextend 操作码时，它将检查有符号整数的符号位，并将其扩展到更高的位数。如果符号位为 1，则 signextend 操作码将在高位添加 1；否则，它将在高位添加 0。这样做可以确保有符号整数的符号位在扩展后保持不变。

### 为什么 calldata 中的负数会消耗更多的 gas？

当您在 Solidity 中使用 calldata 传递负数时，Solidity 会将其转换为补码形式，并将其存储在 calldata 中。由于补码形式需要更多的位来表示负数，因此在 calldata 中存储负数需要更多的空间，从而消耗更多的 gas。这是因为在 Solidity 中，gas 的消耗是与数据大小成正比的。因此，存储更大的数据将导致更多的 gas 消耗。




| 地址范围  | 用途                                    |
|-----------|-----------------------------------------|
| 0x00–0x1F | scratch space                           |
| 0x20–0x3F | 自由内存指针值存储槽（FMP 位置）          |
| 0x40      | 自由内存指针位置（即 mload(0x40) = 0x80） |
| 0x60–0x7F | 临时预留空间                            |
| 0x80–...  | 实际可用的自由 memory 开始地址          |

