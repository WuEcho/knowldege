# 智能合约安全



##1.重入攻击

 应用场景主要在于两个合约A合约和B合约，假设A合约为存钱罐合约并提供体现方法，B合约为提款攻击合约，A合约记录了B合约的余额，当B合约拥有了回调函数(fallback())的时候，B合约可以通过回调函数重复调用A合约的提款方法，使得A合约的资产被盗走。
    利用的逻辑即是：A合约的先操作再改变状态的漏洞，以至于每次提款的时候B合约状态没有改变依旧可以继续操作。
    解决以及预防办法：1.先改变状态在进行操作。2.可以通过**重入锁**的方式解决
    
重入锁实现如下：

``` 
bool internal locked;

modifier noReentrant() {
    require(!locked,"no re-entrancy");
    locked = true;
    _;
    locked = false;
}

```

##2.数字溢出

在智能合约中一般使用uint256作为数据的类型来使用，但是uint256的取值范围是0~2**256-1,这就导致了uint256可以上溢出也可以下溢出，对于溢出的情况。可以使用openzepplin中的safeMath来解决


##3.随机数攻击

攻击原理是采用了区块难度，区块时间戳之类的伪随机数作为产生随机数的种子，产生的随机数是可以被预测的。可以通过第三方接口获取随机数或预言机来获取随机数，如：randow.org产生jeson形式的随机数并通过数字签名的方式确认随机数没有被修改

##4.自毁攻击

通过利用selfdestruct函数的强制转账功能，向目标地址强制转账。
解决办法是：不要以合约余额作为判断条件，可以通过定义一个状态变量


